전자정부 프레임워크 (eclipse)
eclipse를 자유자재로 사용할 줄 알아야 한다.

.exe 설치파일은 윈도우 검색으로 바로 실행가능하다.
현업에선 압축파일로 받는 추세이다. 검색하여 실행은 못하나, 압축파일로 받게되면 원하는 폴더에 이동시켜 사용할 수 있다.
Eclipse IDE for Enterprise Java and Web Developers 다운.
Enterprise(분산된)

Temurin -> OpenJDK
우리는 풀스택 개발자 과정을 위해 Temurin을 다운받는다.

개발 tool이 최소로 요구하는 JDK-버전이 있다고 했었다.
(이클립스를 실행하기 위한 Java-버전이 필요하다는 것)
-> 프로젝트시 예전 JDK-버전을 사용하는데 제한은 없다.

관리자 권한으로 install 파일을 실행하여 설치 폴더를 '유저'가 아닌 C드라이브의 Program Files에 다운로드하면,
해당 컴퓨터의 모든 사용자가 사용가능하다.

내가 프로젝트를 할 Workspace 설정한다. (로컬 디스크 D:\KosaCourse\projects)
실행 후, Open perspective를 눌러 Java를 추가한다.
Open perspective -> 내가 개발하는 환경에 맞추어 UI를 선택 (view뿐만 아니라 menu도 바뀜)

menu란의 [window]를 눌러 view를 선택할 수 있다.
우선 다른창은 모두 닫고 Package Explorer, console view만 열어보자.

프로젝트 생성 new -> java project
JRE -> 프로젝트에 맞는 JavaSE-버전을 선택한다. **
여기서 내가 1.8버전을 사용한다치면 내 pc에 꼭 1.8버전이 있어야 사용가능하다.
따라서 Conpigure JRE.. 에서 내가 다운받았던 JDK-버전 폴더들을 추가해준다.
Add -> Standard VM -> JRE home에 내가 다운받은 JDK-버전 폴더 디렉토리를 등록!


execution environment 에서 JavaSE-17를 선택하는 의미 : JDK-17.0.21이라하면, 뒤의 update는 상관없이 JDK-17만 환경이 맞으면 된다는 뜻이고,
specific JRE 에서는 update된 내용까지 정확히 사용하겠단 의미이다.

Configure JREs... 추가기능에서는 내가 사용할 JDK-버전들을 설치, 추가할 수 있다.
여기서 본래 jdk-17을 jdk-17.0.10으로 Edit해주고, 적용해주면 새로 javaproject생성시 jdk-17.0.10으로 사용할 수 있다. (update버전까지 정확히 사용가능)
(사실 update버전까지 민감하게 맞추어가며 개발할 필요성이 그리 높진 않다.)

결과적으로 Use an execution environment JRE의 내가 사용할 JDK버전과 config에서 추가한 JDK-버전을 일치시켜 사용하여야 한다.


Project layout
src폴더와 bin폴더를 분리해서 사용설정

Working sets
건드리지 않음

Module
-> javaSE-11 이상부터 지원
내가 만드는 프로젝트가 라이브러리라 한다면 반드시 체크


이렇게 프로젝트 생성시, javaSE-버전과 src폴더가 생성되어있다.
소스를 작성하고 컴파일하게 되면 bin폴더가 생성된다. --> 패키지 생성과 동시에 bin폴더가 생성된다.

src폴더에 pakage 생성 --> 상위, 하위패키지를 구분 짓는 기호는 '.'이다.
생성 후 폴더들이 생겼는지 확인.

이클립스는 소스를 저장만하면 자동으로 컴파일 된다.(패키지 생성과 동시에 bin폴더가 생성) bin폴더를 확인해보면 바이트코드 파일(.class)가 생성된 것을 확인할 수 있다.

경우에 따라서 소스코드파일을 열지 않고 실행하여 확인할 때가 있으면, 코드소스 우클릭 -> run as -> java application
소스코드가 열려져 있지 않은 상태에서 위쪽의 run을 누르게되면 최근에 사용했던 소스를 작동시킨다.

p30 예제 따라해보기 // 변수 선언하고 출력

소스코드 인코딩 방식은 관례적으로 UTF-8
협업과정에서 각자의 컴퓨터에서 개발할 때 인코딩 방식을 맞춰주어야 한다. 그렇게하지 않으면 예를들어 소스코드 내의 '한글'등 언어가 깨질 수 있다.
메뉴 -> [window] -> [preference] -> [workspace] -> [text file encoding]

앞으로의 과정에서 패키지가 많아지면 익스플로러 창에서 보기 불편할 수 있다. 따라서 왼쪽 상단 view menu에서 패키지 프레젠테이션에서 나열방식을 설정해준다.

소스코드파일의 이름 *.java에서의 *는 소스코드 내의 class 이름과 같아야한다!(무조건)
현재 public, static, void에 관해서 너무 신경쓰지말고 공부하자. 추후에 다 알게된다.

Document 주석이란?
- 사람을 위한 주석이 아니다.
- 클래스나 메소드 위에 /** 후 엔터를 치게되면 주석이 만들어지는데, 이것은 api를 이용하여 HTML파일로 만들어준다...?
- java 1.8 api document 검색하여 overview사이트에서 참고

현 시점에서 행주석과 범위주석은 필수로 알아야한다.

*범위 주석 설정 변경하기
메뉴 -> [window] -> [Preferences] -> [java] -> [Code Style] -> [Formatter] -> new로 새로 생성 -> My Formatter이라 이름짓고 [Comments] 의 3번째 체크 해제하기

실행문 뒤에는 무조건 세미클론(;)을 후미에 붙여주어야 한다.(기본, 무조건)

확인문제 풀고 챕터 1 마무리

----

챕터 2

변수 선언의 관례와 변수 타입
변수 이름을 '한글'로 사용가능하긴 한데, 영어로만 사용하자.
변수 선언과 동시에 초기화 방법

p37부터 예제 계속해서 이해하고 출력하기.

System.out.println("a + b = " + 10); 이 코드에서 10은 숫자이나, 컴파일 과정에서 "a + b = "과의 문자열 결합 연산이 된다. (이 실행코드 내에서 실행될 때 10은 문자열이라는 의미이다.)

정수 타입
변수 타입에 따라 저장할 수 있는 값의 종류와 허용 범위가 달라진다.
기본 타입 8개는 암기하자.
(정수 타입) byte, char, short, int, long
(실수 타입) float, double
(논리 true/false) boolean

bit(비트)는 0과 1로 표현할 수 있는 정보의 단위이다.
byte는 8비트와 같다.
1bit -> 1byte -> 1kbyte -> 1mbyte -> 1gbyte -> 1tbyte
          1바이트부터 1000단위로 단위명칭이 바뀐다. 정확하게는 '1024배'이다.

byte 타입 선언 예제 사용 후 확인

기본적으로 프로그램은 메모리를 적게 사용하는 것이 좋다.
하지만 cpu의 기본설계에 따라 달라진다.
예를들어, 정수형 타입 1byte + 1byte를 계산하는데 해당 cpu는 정수형 타입을 4byte 표준으로하여 계산하기 때문에 4byte + 4byte 형식으로 바꾸어 계산하게 된다. 이러한 과정에서 1byte를 4byte로 변환하기 때문에 어쩌면 시간이 더 들게될 수 있다는 것이다.
그렇기 때문에 int로 선언해서 계산하는 것이 더 빠를 수 있다는 이야기이다.

실제로 코드로 확인해보자.
byte v1 = 30;
byte v2 = 50;
byte result = v1 + v2;
--> result 계산이 안된다. cpu는 정수형 기본데이터 타입을 4byte단위로 계산하기 때문에 result의 결과값이 1byte이기 때문에 오류가 난다. 때문에 result 선언 타입이 4byte이상이 되어야 한다는 것이다. int result로 선언하거나 long result로 선언해야한다.

리터럴 : 코드 상에 내가 직접 입력하는 것
int 범위를 넘는 숫자를 리터럴로 사용하는 경우 맨 뒤에 'L'을 붙여주어야 한다.
-> Java 컴파일러는 정수형 타입을 4byte(int범위)를 기준으로 숫자를 인식하기 때문

변수를 연산하는 것과 리터럴을 연산하는 것은 다르다..
위의 byte result = v1 + v2; 이것은 컴파일 에러가 일어나지만
byte result = 30 + 50; 은 에러가 나지 않는다. (byte result = 80; 으로 인식)

char는 정수타입이다.
char var1 = 'A'; 에서 작은따옴표(')로 감싼 것을 문자 리터럴이라 한다.
문자 리터럴은 유니코드로 변환되어 저장되는데, 숫자로 매핑한 국제 표준 규약이다.
따라서 char var2 = 65; 한다면 var1과 var2는 같은 값을 나타낸다.

char c5 = ''; // 컴파일 에러가 일어난다. 작은따옴표 사이에 공백하나를 두어서 초기화 시킨다.
char c6 = ' '; // 빈 문자(공백)는 숫자와 매핑되어있어서 에러가 생기지 않는다.

float v1 = 0.1234567890123456789F; // Java는 기본적으로 실수 데이터 타입을 8byte(double) 기준으로 연산한다. 따라서 맨뒤에 f 또는 F를 붙여주어야 한다.
double v2 = 0.1234567890123456789;

float은 소수점 8자리까지 출력 (마지막에 반올림한다)
double은 소수점 16자리까지 출력 (마지막에 반올림한다)
--> 결과적으로 double이 정밀도가 더 높고, 8byte기준으로 계산하기 때문에 더 빠를 수 있다!
==> 특별한 이유가 없다면 float보다 double을 사용하자!!

float v3 = 1000000000000F; // float도 int도 4byte인데, float은 어떻게 int보다 큰 수를 변수에 대입할 수 있을까?
'수'를 표현하는 저장방식이 다르기 때문이다. float은 지수와 가수부분만 저장하기 때문에 훨씬 더 큰 수를 넣을 수 있다.
1000 ==> 가수 1, 지수 3 // 이렇게 지수와 가수 1,3만 저장하기 때문에 실수타입은 정수타입보다 훨~씬 더 큰 수를 표현할 수 있다.

double v4 = 10000000000000L;
double v5 = 10000000000000.0; // 사실상 이렇게 큰 숫자를 다룰 경우가 극히 드물다

cf) 프로그램에서 가수, 지수 표현이 나온다면 무조건 실수타입이다.

결론적으로 그냥 정수타입을 선언할 땐 int, 실수타입을 선언할 땐 double만 사용하면 된다.

boolean은 1byte의 크기를 가진다. 실상 True는 1, False는 0으로 1비트만으로 표현 가능하다. 하지만 여기에서 1byte는 크게 의미가 없다. 그냥 넘어간다.

String str = "나는 \n\"자바\"를 \n배웁니다.";  // 이스케이프 문자 표현
System.out.println(str);
--> \" , \\, \t, \n 정도는 알아두자.

cf) window 명령프롬프트에서 값을 입력하고 엔터를 치게되면 끝에 \r\n이 따라 붙어서 입력된다.